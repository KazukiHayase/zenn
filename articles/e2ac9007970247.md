---
title: "Next.js App RouterとApollo Clientの組み合わせ方と仕組みの解説"
emoji: "🐙"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["nextjs", "react", "apollo", "graphql", "typescript"]
published: false
publication_name: "drsprime"
---

最近のプロジェクトでNext.jsのApp Routerへの移行を進めていて、その過程でApp RouterとApollo Clientの連携について色々とキャッチアップする機会がありました。
今回は、App RouterとApollo Clientを組み合わせた場合の実装方法と内部の仕組みについて紹介したいと思います！

記事の中で使用するサンプルコードは下記にあるので、興味があれば見てみてください。

https://github.com/KazukiHayase/app-router-apollo-client-catch-up

# App Router + Apollo Clientの実装方法

App RouterとApollo Clientを組み合わせる場合は、[@apollo/client-integration-nextjs](https://github.com/apollographql/apollo-client-integrations)を使用します。

https://github.com/apollographql/apollo-client-integrations

## Server Componentsの場合

Server Components(以下SC)でApollo Clientを使用するために、Apollo Clientのインスタンスを`registerApolloClient`で登録します。

```ts
import {ApolloClient, HttpLink, InMemoryCache} from "@apollo/client";
import {registerApolloClient} from "@apollo/client-integration-nextjs";

export const {getClient} = registerApolloClient(() => {
  return new ApolloClient({
    cache: new InMemoryCache(),
    link: new HttpLink({
      uri: "http://localhost:3000/api/graphql",
    }),
  });
});
```

上記で登録したインスタンスを、各コンポーネントで使用することで、SCでQueryを実行することができます。

```tsx
import gql from "graphql-tag";
import {getClient} from "@/app/ApolloClient";

const userQuery = gql`
  query {
    getUser(id: "1") {
      id
      name
    }
  }
`;

export default async function Page() {
  const {data} = await getClient().query({query: userQuery});

  return <p>data received during Page render: {JSON.stringify(data)}</p>;
}
```

後ほど説明しますが、`getClient`内部では、Reactの[cache](https://ja.react.dev/reference/react/cache)が使用されており、同一リクエスト内では同一のインスタンスが使用されるようになっています。
そのため、`getClient`はコンポーネント内で呼び出す必要があります。

## Client Componentsの場合

Client Components(以下CC)の場合は、`@apollo/client-integration-nextjs`のProviderを使用して、Apollo Clientのインスタンスを登録します。
従来の`@apollo/client`の`ApolloProvider`では、すでにインスタンス化された`client`オブジェクトをPropsで受け取りますが、`ApolloNextAppProvider`ではインスタンスを生成するための`makeClient`という関数を受け取ります。（この理由については後ほど説明します）

```tsx
"use client";

import {HttpLink} from "@apollo/client";
import {
  ApolloNextAppProvider,
  ApolloClient,
  InMemoryCache,
} from "@apollo/client-integration-nextjs";

function makeClient() {
  const httpLink = new HttpLink({
    uri: "http://localhost:3000/api/graphql",
  });

  return new ApolloClient({
    cache: new InMemoryCache(),
    link: httpLink,
  });
}

export function ApolloWrapper({children}: React.PropsWithChildren) {
  return (
    <ApolloNextAppProvider makeClient={makeClient}>
      {children}
    </ApolloNextAppProvider>
  );
}
```

## fetchOptionsについて

Next.js App RouterではNext.js独自に拡張された`fetch`関数が使用されており、この関数にはキャッシュ制御などのためのオプションを渡すことができます。Apollo Clientでも、この拡張されたfetchオプションを活用することができます。

Apollo Clientのインスタンスを生成する際に、`HttpLink`のオプションとして`fetchOptions`を指定することで、すべてのGraphQLリクエストにNext.jsのfetchオプションを適用できます。

```ts
export const {getClient} = registerApolloClient(() => {
  return new ApolloClient({
    cache: new InMemoryCache(),
    link: new HttpLink({
      uri: "http://localhost:3000/api/graphql",
      fetchOptions: {
        cache: "no-store",
        next: {revalidate: 0},
      },
    }),
  });
});
```

インスタンス生成時に指定したオプションをリクエストごとにオーバーライドしたい場合は、Query実行時に`context`で`fetchOptions`を指定することができます。

```tsx
export default async function Page() {
  const {data} = await getClient().query({
    query: userQuery,
    context: {
      fetchOptions: {
        cache: "force-cache",
        next: {revalidate: 10},
      },
    },
  });

  return <p>data received during Page render: {JSON.stringify(data)}</p>;
}
```

指定できるオプションは、Next.jsの`fetch`関数で指定できるものと同じです。

https://nextjs.org/docs/app/api-reference/functions/fetch#fetchurl-options

# キャッシュについて

- Next.jsのfetchではこうしてる、Apolloではこうしている
- 下記のページのやつを、図を作ってApollo用に紹介する
  - request momeizationがインスタンスになる、data cacheはNext.jsのもの
- https://nextjs.org/docs/app/deep-dive/caching#request-memoization
- CCの場合もリクエストごとにインスタンスを分けるように
  - CCは初回はSSRされることに触れた方が良さそう

# 注意点

- SCはサーバーでのみレンダリングされ、CCはサーバーとクライアントの両方でレンダリングされる
- CCはSSRされる可能性がある
- そのため、RSCとSSRを明確に使い分ける、公式でも言及されている
- 完全に使い分ける必要がある
- https://github.com/apollographql/apollo-client-integrations/tree/main/packages/nextjs#usage

# GraphQLとReact Server Componentsの併用について

- GraphQLとRSCは同じ課題を解決する異なるアプローチ
- どちらも、自律的かつ効率的にデータを宣言・取得することを目指している
- 今ゼロからアプリケーションを作るなら、併用する必要はない
- ただ、現行でGraphQLを使っている場合のAppRouterへの移行は必要
- その際のやり方は色々ある

## 設計方針

- どのように併用するか
- このように実装して欲しいという思想はApolloにはなさそう？
- Next.jsに依存しない、将来的に脱することを視野に入れる -> colocationは継続
- Next.jsに依存してRSCの恩恵享受を狙う、REST等への移行を視野に入れる -> SCを積極的に使用していく
- Colocationしてrootでリクエストするのがちょうど良いのでは？
  - そこまで無理してSCを使う必要性はないので、CSに寄せるとかはあり、チームの方針によると思う
  - leafでリクエストしても、memorizeはされない
- Fragment Colocationについて
- やる方が良い
- Next.jsを剥がすかもしれないし、CCで使いたいかもしれない
- leafで取得するか迷うので、rootで取得に統一の方が良い
- CSに寄せるのもアリかも

# まとめ

<!-- 

# 参考 
- https://zenn.dev/cybozu_frontend/articles/next-caching-dedupe#automatic-fetch()-request-deduping-%2F-fetch()-%E3%81%AE%E8%87%AA%E5%8B%95%E9%87%8D%E8%A4%87%E6%8E%92%E9%99%A4
- https://github.com/apollographql/apollo-client-integrations/tree/main/packages/nextjs

-->
