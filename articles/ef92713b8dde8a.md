---
title: "Goã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ã£ã¦ã€ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆ(TDT)ã«çµ±ä¸€æ€§ã‚’æŒãŸã›ã‚‹"
emoji: "ğŸƒ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "test", "testing", "generics"]
published: true
publication_name: "buyselltech"
---

ç§ã¯æ™®æ®µGoã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ãéš›ã«ã€ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆ(TDT)ã‚’ç”¨ã„ã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚
ã—ã‹ã—ã€ãƒãƒ¼ãƒ ã§é–‹ç™ºã‚’ã—ã¦ã„ã‚‹ã¨ã€ãƒ¡ãƒ³ãƒãƒ¼ã«ã‚ˆã£ã¦ãƒ†ã‚¹ãƒˆã®æ›¸ãæ–¹ãŒç•°ãªã‚‹ã“ã¨ãŒã—ã°ã—ã°ã‚ã‚Šã€ãã‚Œã«ã‚ˆã‚Šã€ãƒ†ã‚¹ãƒˆã‚’å®Ÿè£…ã™ã‚‹éš›ã«æ›¸ãæ–¹ã«è¿·ã£ãŸã‚Šã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒã—ã¥ã‚‰ããªã£ãŸã‚Šã¨ã€ãƒ†ã‚¹ãƒˆã®å®Ÿè£…ã«ãŠã„ã¦å•é¡ŒãŒç”Ÿã˜ã¦ã„ã¾ã—ãŸã€‚
ãã“ã§ã€ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€æ±ç”¨çš„ã«ä½¿ãˆã‚‹ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®æ§‹é€ ä½“ã‚’å®šç¾©ã—ã€ãã‚Œã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã§å…±é€šã§ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆã®æ›¸ãæ–¹ã«çµ±ä¸€æ€§ã‚’æŒãŸã›ã‚‹ã“ã¨ãŒã§ããŸã®ã§ã€ä»Šå›ã¯ãã®æ–¹æ³•ã‚’ç´¹ä»‹ã—ãŸã„ã¨æ€ã„ã¾ã™ï¼

# ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆã¨ã¯

ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆã¨ã¯ã€è¤‡æ•°ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’ã‚¹ãƒ©ã‚¤ã‚¹ã§å®šç¾©ã—ã€ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ã§ä¸€ã¤ã®ãƒ†ã‚¹ãƒˆé–¢æ•°ã§è¤‡æ•°ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’å®Ÿè¡Œã™ã‚‹æ–¹æ³•ã§ã™ã€‚

```go
package main

func Sum(numbers []int) int {
	total := 0
	for _, n := range numbers {
		total += n
	}
	return total
}

func TestSum(t *testing.T) {
	cases := []struct {
		name    string
		numbers []int
		want    int
	}{
		{"ç©ºã®ã‚¹ãƒ©ã‚¤ã‚¹", []int{}, 0},
		{"1ã¤ã®è¦ç´ ", []int{42}, 42},
		{"è¤‡æ•°ã®è¦ç´ ", []int{1, 2, 3, 4}, 10},
		{"è² ã®æ•°ã‚’å«ã‚€", []int{-1, -2, -3, -4}, -10},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			got := Sum(tc.numbers)
			if got != tc.want {
				t.Errorf("Sum(%v) = %d, want %d", tc.numbers, got, tc.want)
			}
		})
	}
}
```

https://go.dev/wiki/TableDrivenTests

ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆã«ã¯ã€ä¸‹è¨˜ã®ã‚ˆã†ãªãƒ¡ãƒªãƒƒãƒˆãŒã‚ã‚Šã¾ã™ã€‚

- ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®è¿½åŠ ãƒ»ç·¨é›†ãƒ»å‰Šé™¤ãŒã—ã‚„ã™ã„
- ãƒ†ã‚¹ãƒˆã®æœŸå¾…å€¤ãŒæ˜ç¢ºã«ãªã‚‹
- ç¹°ã‚Šè¿”ã—å®Ÿè¡Œã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã‚’Runã«é›†ç´„ã§ãã‚‹

# ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆã®è¨˜æ³•ãŒãƒãƒ©ãƒãƒ©ã«ãªã‚‹å•é¡Œ

ä¸Šè¨˜ã®ä¾‹ã®ã‚ˆã†ã«ã€ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ­ã‚¸ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆã§ã‚ã‚Œã°ã€ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆã‚’ç”¨ã„ã¦ã€ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«ä¿ã¤ã“ã¨ãŒã§ãã¾ã™ã€‚
ãŸã ã€Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ­ã‚¸ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆã®éš›ã«ã¯ã€è¿”ã‚Šå€¤ã®æ¤œè¨¼ã«åŠ ãˆã¦ã€DBã‚„ãƒ¢ãƒƒã‚¯ãªã©ã®æº–å‚™ã‚„æ¤œè¨¼ã‚‚è¡Œã„ãŸã„å ´é¢ãŒã‚ã‚Šã¾ã™ã€‚
ãã‚Œã‚‰ã‚’å–ã‚Šå…¥ã‚Œã‚‹éš›ã«ã€ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«é–¢æ•°ã‚’è¿½åŠ ã—ã¦ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ›¸ã„ãŸã‚Šã€Runã®ä¸­ã§å®Ÿè¡Œã—ãŸã‚Šãªã©ã€å®Ÿç¾æ–¹æ³•ãŒè¤‡æ•°å­˜åœ¨ã—ã€ãã‚Œã«ã‚ˆã£ã¦è¨˜æ³•ãŒãƒãƒ©ãƒãƒ©ã«ãªã‚‹å•é¡ŒãŒç™ºç”Ÿã—ã¦ã„ã¾ã—ãŸã€‚

ãã“ã§ã€ä½•ã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ãã‹ã‚„èª°ãŒæ›¸ãã‹ã«ã‚ˆã‚‰ãšã€è¨˜æ³•ã‚’çµ±ä¸€ã™ã‚‹ãŸã‚ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã§å…±é€šã§ä½¿ç”¨ã™ã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆç”¨ã®æ§‹é€ ä½“ã‚’å®šç¾©ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚


# ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆç”¨ã®æ§‹é€ ä½“

æ§‹é€ ä½“ã®å®šç¾©ã¯ä¸‹è¨˜ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å‹å®šç¾©ã«ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€å¼•æ•°ã‚„è¿”ã‚Šå€¤ã®å‹ã‚’ãƒ†ã‚¹ãƒˆã«å¿œã˜ã¦å¤‰ãˆã‚‰ã‚Œã‚‹ã®ã§ã€æ±ç”¨çš„ã«ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚

```go
type TestCase[TArgs, TResult, TMockFields any] struct {
	// ãƒ†ã‚¹ãƒˆå
	Name string
	// ãƒ†ã‚¹ãƒˆã™ã‚‹é–¢æ•°ã®å¼•æ•°
	Args TArgs

	// DBãªã©ã‚’æ“ä½œã™ã‚‹æº–å‚™
	Prepare func()
	// ãƒ¢ãƒƒã‚¯ã®æº–å‚™
	PrepareMock func(m *TMockFields)

	// DBãªã©ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
	Assert func()
	// è¿”ã‚Šå€¤ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
	AssertResult func(r TResult)
	// ãƒ¢ãƒƒã‚¯ã®ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
	AssertMock func(m *TMockFields)
}
```

# ä½¿ç”¨ä¾‹

ä¸Šè¨˜ã®æ§‹é€ ä½“ã‚’ä½¿ã£ãŸãƒ†ã‚¹ãƒˆå®Ÿè£…ã®ä¾‹ã‚’ã„ãã¤ã‹ç´¹ä»‹ã—ã¾ã™ã€‚
æ§‹é€ ä½“ã®å…¨ã¦ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ã¯ãªã„ã®ã§ã€ãƒ†ã‚¹ãƒˆã«ã‚ˆã£ã¦ã¯ä½¿ã‚ãªã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯çœç•¥ã—ã¦ã‚‚å¤§ä¸ˆå¤«ã§ã™ã€‚

## ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ­ã‚¸ãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆ

```go
package main

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestSumWithTestCase(t *testing.T) {
	type args struct {
		numbers []int
	}

	type result struct {
		sum int
	}

	testcases := []TestCase[args, result, any]{
		{
			Name: "ç©ºã®ã‚¹ãƒ©ã‚¤ã‚¹",
			Args: args{
				numbers: []int{},
			},
			AssertResult: func(r result) {
				assert.Equal(t, 0, r.sum)
			},
		},
		{
			Name: "1ã¤ã®è¦ç´ ",
			Args: args{
				numbers: []int{42},
			},
			AssertResult: func(r result) {
				assert.Equal(t, 42, r.sum)
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.Name, func(t *testing.T) {
			got := Sum(tc.Args.numbers)
			tc.AssertResult(result{sum: got})
		})
	}
}
```

## ãƒ¢ãƒƒã‚¯ã‚’ä½¿ç”¨ã™ã‚‹ãƒ†ã‚¹ãƒˆ

:::details ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®ã‚³ãƒ¼ãƒ‰
```go
package main

import "errors"

type Interface1 interface {
	Run() string
}

type Interface2 interface {
	Run() string
}

type SomeService struct {
	i1 Interface1
	i2 Interface2
}

func (s *SomeService) Run(str string) (string, error) {
	str1 := s.i1.Run()
	str2 := s.i2.Run()

	if str == "" && str1 == "" && str2 == "" {
		return "", errors.New("error")
	}

	return str + str1 + str2, nil
}

func NewSomeService(i1 Interface1, i2 Interface2) *SomeService {
	return &SomeService{i1: i1, i2: i2}
}
```
:::

:::details ãƒ¢ãƒƒã‚¯å®šç¾©
```go
package main

import (
	"github.com/stretchr/testify/mock"
)

type MockInterface1 struct {
	mock.Mock
}

func (m *MockInterface1) Run() string {
	return m.Called().String(0)
}

type MockInterface2 struct {
	mock.Mock
}

func (m *MockInterface2) Run() string {
	return m.Called().String(0)
}
```
:::

```go
package main

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestSomeService_Run(t *testing.T) {
	type args struct {
		str string
	}

	type result struct {
		str string
		err error
	}

	type mockFields struct {
		i1 *MockInterface1
		i2 *MockInterface2
	}

	testcases := []TestCase[args, result, mockFields]{
		{
			Name: "æ­£å¸¸ç³»",
			Args: args{
				str: "test",
			},
			PrepareMock: func(m *mockFields) {
				m.i1.On("Run").Return("a")
				m.i2.On("Run").Return("b")
			},
			AssertResult: func(r result) {
				assert.NoError(t, r.err)
				assert.Equal(t, "testab", r.str)
			},
			AssertMock: func(m *mockFields) {
				m.i1.AssertCalled(t, "Run")
				m.i2.AssertCalled(t, "Run")
			},
		},
		{
			Name: "ç•°å¸¸ç³»",
			Args: args{
				str: "",
			},
			PrepareMock: func(m *mockFields) {
				m.i1.On("Run").Return("")
				m.i2.On("Run").Return("")
			},
			AssertResult: func(r result) {
				assert.EqualError(t, r.err, "error")
			},
			AssertMock: func(m *mockFields) {
				m.i1.AssertCalled(t, "Run")
				m.i2.AssertCalled(t, "Run")
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.Name, func(t *testing.T) {
			t.Log(tc.Name)
			mockFields := &mockFields{
				i1: new(MockInterface1),
				i2: new(MockInterface2),
			}
			tc.PrepareMock(mockFields)

			svc := NewSomeService(mockFields.i1, mockFields.i2)
			got, err := svc.Run(tc.Args.str)

			tc.AssertResult(result{str: got, err: err})
			tc.AssertMock(mockFields)
		})
	}
}
```

## DBæ“ä½œã‚’è¡Œã†ãƒ†ã‚¹ãƒˆ

:::details ãƒ†ã‚¹ãƒˆå¯¾è±¡ã®ã‚³ãƒ¼ãƒ‰
```go
package main

import (
	"database/sql"
	"errors"
)

type User struct {
	ID   string
	Name string
}

func UpdateUser(db *sql.DB, user User) error {
	var count int
	err := db.QueryRow("SELECT COUNT(*) FROM users WHERE id = $1", user.ID).Scan(&count)
	if err != nil {
		return err
	}
	if count == 0 {
		return errors.New("user not found")
	}

	_, err = db.Exec("UPDATE users SET name = $1 WHERE id = $2", user.Name, user.ID)
	return err
}
```
:::


```go
package main

import (
	"database/sql"
	"testing"

	_ "github.com/lib/pq"
	"github.com/stretchr/testify/assert"
)

func TestUpdateUser(t *testing.T) {
	var userID = "1"

	db, err := sql.Open("postgres", "...")
	if err != nil {
		assert.Fail(t, err.Error())
	}
	defer db.Close()

	type args struct {
		user User
	}

	type result struct {
		err error
	}

	testcases := []TestCase[args, result, any]{
		{
			Name: "æ­£å¸¸ç³»",
			Args: args{
				user: User{
					ID:   userID,
					Name: "test-update",
				},
			},
			Prepare: func() {
				_, err := db.Exec("INSERT INTO users (id, name) VALUES ($1, 'test')", userID)
				if err != nil {
					assert.Fail(t, err.Error())
				}
			},
			AssertResult: func(r result) {
				assert.NoError(t, r.err)
			},
			Assert: func() {
				user, err := selectUser(db, userID)
				if err != nil {
					assert.Fail(t, err.Error())
				}
				assert.Equal(t, "test-update", user.Name)
			},
		},
		{
			Name: "ç•°å¸¸ç³»",
			Args: args{
				user: User{
					ID:   "not-exist-id",
					Name: "test-update",
				},
			},
			Prepare: func() {},
			AssertResult: func(r result) {
				assert.EqualError(t, r.err, "user not found")
			},
			Assert: func() {
				user, err := selectUser(db, "not-exist-id")
				assert.Error(t, err)
				assert.Empty(t, user)
			},
		},
	}

	for _, tc := range testcases {
		t.Run(tc.Name, func(t *testing.T) {
			tc.Prepare()

			err := UpdateUser(db, tc.Args.user)

			tc.AssertResult(result{err: err})
			tc.Assert()
		})
	}
}

func selectUser(db *sql.DB, id string) (User, error) {
	var user User
	err := db.QueryRow("SELECT id, name FROM users WHERE id = $1", id).Scan(&user.ID, &user.Name)
	return user, err
}
```

# ã¾ã¨ã‚

ä»Šå›ã¯Goã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä½¿ã£ã¦ã€ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆã«çµ±ä¸€æ€§ã‚’æŒãŸã›ã‚‹æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã—ãŸã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€ç§ã®ãƒãƒ¼ãƒ ã§ã¯ãƒ†ã‚¹ãƒˆã®å®Ÿè£…æ–¹æ³•ã«è¿·ã†ã“ã¨ãŒæ¸›ã‚Šã€å®Ÿè£…ã‚¹ãƒ”ãƒ¼ãƒ‰å‘ä¸Šã«ã‚‚ç¹‹ãŒã£ã¦ã„ã¾ã™ã€‚
ã¾ãŸã€æ§‹é€ ä½“ã®å‹å®šç¾©ã¯ãƒãƒ¼ãƒ ã®æ–¹é‡ã«åˆã‚ã›ã¦å®šç¾©ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚ŠåŠ¹æœçš„ã«ä½¿ãˆã‚‹ã¨æ€ã„ã¾ã™ã€‚

ä¸€æ–¹ã§ã€ä»Šå›ç´¹ä»‹ã—ãŸæ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å…¨ã¦ä½¿ã†å¿…è¦ãŒã‚ã‚‹å ´åˆãªã©ã§ã¯ã€ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆã‚’æ¡ç”¨ã™ã‚‹ã“ã¨ã§ã€é€†ã«ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ãŒè‚¥å¤§åŒ–ã—ã€å¯èª­æ€§ãŒä½ä¸‹ã™ã‚‹å ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚
ãã®ãŸã‚ã€å ´åˆã«ã‚ˆã£ã¦ã¯ãƒ†ãƒ¼ãƒ–ãƒ«é§†å‹•ãƒ†ã‚¹ãƒˆãã®ã‚‚ã®ã‚’ä½¿ã‚ãªã„æ–¹ãŒè‰¯ã„å ´åˆã‚‚ã‚ã‚‹ã¨æ€ã†ã®ã§ã€çŠ¶æ³ã«å¿œã˜ã¦ä½¿ã„åˆ†ã‘ã‚‹ã“ã¨ã‚‚å¤§äº‹ã ã¨æ€ã„ã¾ã™ã€‚
